/**
 * Meta-Agent Schemas — Output schemas for the Capitalizer, Mutator, and Provisioner.
 * Enforced by docs/api_and_interfaces.md §1F-G and docs/engineering_implementation.md §3
 */
import { z } from "zod/v4";

/**
 * The Capitalizer's strategic hint output, injected into the active speaker's
 * EnvironmentState to accelerate resolution.
 * @see docs/api_and_interfaces.md §1F — The Capitalizer
 */
export const CapitalizerHint = z.object({
    overlap_detected: z.boolean(),
    confidence_score: z.number().int().min(1).max(10),
    strategic_hint: z.string(),
    rationale: z.string(),
});
export type CapitalizerHint = z.infer<typeof CapitalizerHint>;

/**
 * A single mutation variant generated by the Mutator.
 * @see docs/core_system_prompts.md §2 — The Mutator Prompt
 */
export const MutationVariant = z.object({
    variant_id: z.string().describe("A unique ID for this mutation variant."),
    strategy_text: z.string().describe("The evolved strategy text for the agent."),
    hyperparameters: z.object({
        temperature: z.number().min(0).max(2).describe("LLM temperature (0.0 to 2.0)."),
        frequency_penalty: z.number().min(0).max(2).describe("LLM frequency penalty (0.0 to 2.0)."),
    }).describe("Model hyperparameters for this variant."),
});
export type MutationVariant = z.infer<typeof MutationVariant>;

/**
 * The Mutator's complete output: three distinct strategy permutations.
 * @see docs/self_improvement_loop.md §3A — Phase A: Generation
 */
export const MutatorProposal = z.object({
    variants: z.array(MutationVariant).min(1).max(5),
});
export type MutatorProposal = z.infer<typeof MutatorProposal>;

/**
 * Permissions scope for a Provisioner-designed agent.
 * Enforced by the EnvironmentManager on every turn.
 * @see docs/engineering_implementation.md §3 — NewAgentProvisioning Schema
 */
export const AgentPermissions = z.object({
    can_modify_fields: z.array(z.string()).describe("State object paths this agent can modify"),
    cannot_modify_fields: z.array(z.string()).describe("State object paths explicitly denied"),
    can_abort_episode: z.boolean().describe("Whether this agent can terminate the episode early."),
    can_propose_resolution: z.boolean().describe("Whether this agent can propose a final agreement."),
    max_state_mutations_per_turn: z.number().int().describe("Max number of state fields this agent can change per turn."),
});
export type AgentPermissions = z.infer<typeof AgentPermissions>;

/**
 * Complete specification for a dynamically provisioned agent.
 * Output by the Provisioner Meta-Agent.
 * @see docs/engineering_implementation.md §3 — NewAgentProvisioning Schema
 */
export const NewAgentProvisioning = z.object({
    agent_id: z.string().describe("A unique identifier for the new agent"),
    archetype: z.string().describe("e.g., 'broker', 'validator', 'proxy_actor', 'disruptor'"),
    turn_injection_logic: z.string().describe("e.g., 'speak_every_3_turns'"),
    system_prompt: z.string().describe("The complete Layer 1 immutable core prompt"),
    core_goals: z.array(z.string()),
    permissions: AgentPermissions,
    design_rationale: z.string().describe("Why this agent breaks the deadlock"),
});
export type NewAgentProvisioning = z.infer<typeof NewAgentProvisioning>;
